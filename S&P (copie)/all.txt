<sequential 1>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>



int op1(int z)
{
    z++;
    return z;
}

int op2(int m)
{
    m--;
    return m;
}

void op3(int j, int h)
{
    printf("%d %d", j,h);
}

int main()
{
//op1 0
//op2 0
//op3 2

int a;
int d;
int b = 0;
int c = 2;


a = op1(b);
d = op2(c);

op3(a,d);

}

<parallel 1>

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <pthread.h>
#include "mythreads.h"



typedef struct
{

int ini_a;
int ini_b;
int ini_c;
int ini_d;


int nb_for_op3;

pthread_mutex_t mutex_pile;
pthread_cond_t cond_pile;

ThreadPool *pool;
}
data;

void op3(void *ll)
{
 data *dd = ll;
 printf("%d %d", dd->ini_a, dd->ini_d);
}

void notifier(char name[],void *ll )
{
    data *dd = ll;
    if(strcmp (name, "op3") == 0)
    {   
        --dd->nb_for_op3;
        
        if(dd->nb_for_op3 == 0)
        {
            
            addJobToPool(dd->pool, &op3, ll);
        }
    }


}



void op2(void *ll)
{
    data *dd = ll;
    --dd->ini_c;
    dd->ini_d = dd->ini_b;
    pthread_mutex_lock (&dd.mutex_pile);
    pthread_cond_wait (&dd.cond_pile);
    notifier("op3" , ll);
    pthread_cond_signal (&dd.cond_pile);
    pthread_mutex_unlock (&dd.mutex_pile);
    
    
}
void op1(void *ll)
{
    data *dd = ll;
    ++dd->ini_b; 
    dd->ini_a = dd->ini_b;
    pthread_mutex_lock (&dd.mutex_pile);
    pthread_cond_wait (&dd.cond_pile);
    notifier("op3" , ll);
    pthread_cond_signal (&dd.cond_pile);
    pthread_mutex_unlock (&dd.mutex_pile);
    
}



int main ()
{

data d;

d.mutex_stock = PTHREAD_MUTEX_INITIALIZER;
d.cond_stock = PTHREAD_COND_INITIALIZER;
d.cond_clients = PTHREAD_COND_INITIALIZER;

d.nb_for_op3 = 2;


d.ini_a = 0;
d.ini_d = 0;
d.ini_b = 0;
d.ini_c = 2;



int size = 4;


  
ThreadPool *pool = createPool(size);

d.pool = pool;

addJobToPool(pool, &op1, &d);
addJobToPool(pool, &op2, &d);

printf("POL\n"); 

scanf("FIN%d" , &size2);

}

<sequential 2>

#include <stdlib.h>
#include <string.h>
#include <stdio.h>






int op1(int z)
{
    z++;
    return z;
}

void op2(int m)
{
    printf("%d", m);
}


int main()
{
//op1 0
//op2 1


int a;
int b = 5;


a = op1(b);
op2(a);

//affiche 5

}

<parallel 2>

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <pthread.h>
#include "mythreads.h"


typedef struct
{

int ini_a;
int ini_b;



int nb_for_op2;

pthread_mutex_t mutex_pile;
pthread_cond_t cond_pile;

ThreadPool *pool;
}
data;

void op2(void *ll)
{
    data *dd = ll;
    printf("%d", dd->ini_a);
    
    
}


void notifier(char name[],void *ll )
{
    data *dd = ll;
    if(strcmp (name, "op2") == 0)
    {   
        --dd->nb_for_op2;
        
        if(dd->nb_for_op2 == 0)
        {
            
            addJobToPool(dd->pool, &op2, ll);
        }
    }


}

void op1(void *ll)
{
    data *dd = ll;
    ++dd->ini_b; 
    dd->ini_a = dd->ini_b;
    pthread_mutex_lock (&dd.mutex_pile);
    pthread_cond_wait (&dd.cond_pile);
    notifier("op2" , ll);
    pthread_cond_signal (&dd.cond_pile);
    pthread_mutex_unlock (&dd.mutex_pile);
    
}

int main()
{



data d;

d.mutex_stock = PTHREAD_MUTEX_INITIALIZER;
d.cond_stock = PTHREAD_COND_INITIALIZER;
d.cond_clients = PTHREAD_COND_INITIALIZER;


d.nb_for_op2 = 1;



d.ini_a = 0;
d.ini_b = 5;


int size = 4;


  
ThreadPool *pool = createPool(size);

d.pool = pool;

addJobToPool(pool, &op1, &d);


printf("POL\n"); 
scanf("FIN%d" , &size);



}

<sequential 3>

#include <stdlib.h>
#include <string.h>
#include <stdio.h>






int op1(int z)
{
    z++;
    return z;
}

int op2(int m)
{
    m++;
    return m;
}

void op3(int j)
{
    printf("%d",j);
}

int main()
{
//op1 0
//op2 1
//op3 1

int a;
int b=0;
int d;
a = op1(b);
d = op2(a);
op3(d);

}

<parallel 3>

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <pthread.h>
#include "mythreads.h"


typedef struct
{

int ini_a;
int ini_b;
int ini_d;


int nb_for_op2;
int nb_for_op3;

pthread_mutex_t mutex_pile;
pthread_cond_t cond_pile;

ThreadPool *pool;
}
data;

void op3(void *ll)
{
    data *dd = ll;
     
    printf("%d", dd->d);
       
}

void op2(void *ll)
{
    data *dd = ll;
    ++dd->ini_a; 
    dd->ini_d = dd->ini_a;
    printf("yes");
    pthread_mutex_lock (&dd.mutex_pile);
    pthread_cond_wait (&dd.cond_pile);
    notifier("op3" , ll);
    pthread_cond_signal (&dd.cond_pile);
    pthread_mutex_unlock (&dd.mutex_pile);
    
    
}


void notifier(char name[],void *ll )
{
    data *dd = ll;
    if(strcmp (name, "op2") == 0)
    {   
        --dd->nb_for_op2;
        
        if(dd->nb_for_op2 == 0)
        {
            
            addJobToPool(dd->pool, &op2, ll);
        }
    }
    if(strcmp (name, "op3") == 0)
    {   
        --dd->nb_for_op3;
        
        if(dd->nb_for_op3 == 0)
        {
            
            addJobToPool(dd->pool, &op3, ll);
        }
    }


}

void op1(void *ll)
{
    data *dd = ll;
    ++dd->ini_b; 
    dd->ini_a = dd->ini_b;
    printf("yes");
    pthread_mutex_lock (&dd.mutex_pile);
    pthread_cond_wait (&dd.cond_pile);
    notifier("op2" , ll);
    pthread_cond_signal (&dd.cond_pile);
    pthread_mutex_unlock (&dd.mutex_pile);
}

int main()
{




data d;

d.mutex_stock = PTHREAD_MUTEX_INITIALIZER;
d.cond_stock = PTHREAD_COND_INITIALIZER;
d.cond_clients = PTHREAD_COND_INITIALIZER;

d.nb_for_op2 = 1;
d.nb_for_op3 = 1;



d.ini_a = 0;
d.ini_b = 0;
d.ini_d = 0;

int size = 4;


  
ThreadPool *pool = createPool(size);

d.pool = pool;

addJobToPool(pool, &op1, &d);


printf("POL\n"); 
scanf("FIN%d" , &size);



}

<sequential 4>

#include <stdlib.h>
#include <string.h>
#include <stdio.h>






int op1(int z)
{
    z++;
    return z;
}

int op2()
{
    int z= 0;
    return z;
}

int op3(int m)
{
    

    m++;
    return m;
}

void op4(int a, int b)
{
printf("%d %d", a,b);
}




int main()
{
//op1 0
//op2 1


int a;
int b;
int c;

a = op1(a);
b = op2();
c = op3(a);
op4(c,b);


}

<parallel 4>

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <pthread.h>
#include "mythreads.h"


typedef struct
{

int ini_a;
int ini_b;
int ini_d;


int nb_for_op2;
int nb_for_op3;

pthread_mutex_t mutex_pile;
pthread_cond_t cond_pile;

ThreadPool *pool;
}
data;


void op4(void *ll)
{

data *dd = ll;
     
printf("%d %d", dd->c, dd->b);


}


void op3(void *ll)
{
    data *dd = ll;
    ++dd->ini_a; 
    dd->ini_d = dd->ini_a;
    printf("yes");
    pthread_mutex_lock (&dd.mutex_pile);
    pthread_cond_wait (&dd.cond_pile);
    notifier("op4" , ll);
    pthread_cond_signal (&dd.cond_pile);
    pthread_mutex_unlock (&dd.mutex_pile);
    
    
}

void op2(void *ll)
{
    data *dd = ll;
    int z = 0;
     
    dd->ini_b = z;
    printf("yes");
    pthread_mutex_lock (&dd.mutex_pile);
    pthread_cond_wait (&dd.cond_pile);
    notifier("op3" , ll);
    pthread_cond_signal (&dd.cond_pile);
    pthread_mutex_unlock (&dd.mutex_pile);
    
    
}


void notifier(char name[],void *ll )
{
    data *dd = ll;
    if(strcmp (name, "op3") == 0)
    {   
        --dd->nb_for_op2;
        
        if(dd->nb_for_op2 == 0)
        {
            
            addJobToPool(dd->pool, &op2, ll);
        }
    }
    if(strcmp (name, "op4") == 0)
    {   
        --dd->nb_for_op3;
        
        if(dd->nb_for_op3 == 0)
        {
            
            addJobToPool(dd->pool, &op3, ll);
        }
    }


}

void op1(void *ll)
{
    data *dd = ll;
    ++dd->ini_b; 
    dd->ini_a = dd->ini_b;
    printf("yes");
    pthread_mutex_lock (&dd.mutex_pile);
    pthread_cond_wait (&dd.cond_pile);
    notifier("op3" , ll);
    pthread_cond_signal (&dd.cond_pile);
    pthread_mutex_unlock (&dd.mutex_pile);
}

int main()
{




data d;

d.mutex_stock = PTHREAD_MUTEX_INITIALIZER;
d.cond_stock = PTHREAD_COND_INITIALIZER;
d.cond_clients = PTHREAD_COND_INITIALIZER;

d.nb_for_op3 = 1;
d.nb_for_op4 = 2;



d.ini_a = 0;
d.ini_b = 0;
d.ini_d = 0;

int size = 4;


  
ThreadPool *pool = createPool(size);

d.pool = pool;

addJobToPool(pool, &op1, &d);
addJobToPool(pool, &op2, &d);

printf("POL\n"); 
scanf("FIN%d" , &size);



}